<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PDF TEST 25061110</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #f8f9fa;
            color: #333;
            padding: 8px 12px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            z-index: 1000;
            border-bottom: 1px solid #dee2e6;
            gap: 8px;
        }
        #toolbar button, #toolbar select, #toolbar input[type="file"]::file-selector-button {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            background-color: #fff;
            color: #495057;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #toolbar span {
            font-size: 14px;
            white-space: nowrap;
        }
        #pdf-container {
            position: fixed;
            top: 60px;
            bottom: 0;
            left: 0;
            right: 0;
            overflow: auto;
            background-color: #e9ecef;
            text-align: center;
        }
        #canvas-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #pdf-bg-canvas {
            z-index: 1;
        }
        #pdf-canvas {
            z-index: 2;
            touch-action: none; /* Fabric.js 터치 동작 보장 */
        }
        #mode-indicator {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <input type="file" id="pdf-loader" accept="application/pdf">
        <button onclick="prevPage()">⬅ 이전</button>
        <span>페이지 <span id="page-num">0</span> / <span id="page-count">0</span></span>
        <button onclick="nextPage()">다음 ➡</button>
        <button onclick="setMode('move')">이동</button>
        <button onclick="setMode('draw')">서명</button>
        <input type="color" id="pen-color" value="#E53935">
        <select id="pen-width">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="4">4</option>
            <option value="8">8</option>
        </select>
        <button onclick="undo()">↩ 실행 취소</button>
        <button onclick="redo()">↪ 다시 실행</button>
        <button onclick="zoomIn()">➕ 확대</button>
        <button onclick="zoomOut()">➖ 축소</button>
        <button onclick="exportPDF()">저장하기</button>
    </div>

    <div id="pdf-container">
        <div id="canvas-wrapper">
            <canvas id="pdf-bg-canvas"></canvas>
            <canvas id="pdf-canvas"></canvas>
        </div>
    </div>

    <div id="mode-indicator">모드: 이동</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null, pageNum = 1, scale = 1.5;
        const pdfCanvas = document.getElementById('pdf-canvas');
        const bgCanvas = document.getElementById('pdf-bg-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const ctx = bgCanvas.getContext('2d');
        const penColor = document.getElementById('pen-color');
        const penWidth = document.getElementById('pen-width');
        const modeIndicator = document.getElementById('mode-indicator');

        let fabricCanvas = new fabric.Canvas('pdf-canvas', {
            isDrawingMode: false,
            selection: false
        });

        let mode = 'move';
        let history = [], historyIndex = -1;
        let pageDrawings = {};
        let isDragging = false, startX = 0, startY = 0;

        function setMode(newMode) {
            mode = newMode;
            fabricCanvas.isDrawingMode = (mode === 'draw');
            if (fabricCanvas.isDrawingMode) {
                fabricCanvas.freeDrawingBrush.color = penColor.value;
                fabricCanvas.freeDrawingBrush.width = parseInt(penWidth.value);
            }
            modeIndicator.textContent = '모드: ' + (mode === 'move' ? '이동' : '서명');
        }

        function saveHistory() {
            if (fabricCanvas._loading) return;
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            history.push(JSON.stringify(fabricCanvas));
            historyIndex++;
        }

        async function loadPDF(file) {
            const reader = new FileReader();
            reader.onload = async function () {
                try {
                    const typedArray = new Uint8Array(reader.result);
                    pdfDoc = await pdfjsLib.getDocument({ data: typedArray }).promise;
                    document.getElementById('page-count').textContent = pdfDoc.numPages;
                    pageNum = 1;
                    renderPage(pageNum);
                } catch (err) {
                    alert('PDF 로딩 실패');
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            const page = await pdfDoc.getPage(num);
            const viewport = page.getViewport({ scale });

            bgCanvas.width = pdfCanvas.width = viewport.width;
            bgCanvas.height = pdfCanvas.height = viewport.height;

            bgCanvas.style.width = pdfCanvas.style.width = viewport.width + "px";
            bgCanvas.style.height = pdfCanvas.style.height = viewport.height + "px";

            canvasWrapper.style.width = viewport.width + "px";
            canvasWrapper.style.height = viewport.height + "px";

            await page.render({ canvasContext: ctx, viewport }).promise;

            fabricCanvas.setWidth(viewport.width);
            fabricCanvas.setHeight(viewport.height);
            fabricCanvas.clear();

            if (pageDrawings[num]) {
                fabricCanvas._loading = true;
                fabricCanvas.loadFromJSON(pageDrawings[num], () => {
                    fabricCanvas.renderAll();
                    fabricCanvas._loading = false;
                    saveHistory();
                });
            }

            document.getElementById('page-num').textContent = pageNum;
        }

        function saveCurrentPageDrawing() {
            pageDrawings[pageNum] = JSON.stringify(fabricCanvas);
        }

        function prevPage() {
            if (pageNum <= 1) return;
            saveCurrentPageDrawing();
            pageNum--;
            renderPage(pageNum);
        }

        function nextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            saveCurrentPageDrawing();
            pageNum++;
            renderPage(pageNum);
        }

        function zoomIn() {
            scale *= 1.2;
            renderPage(pageNum);
        }

        function zoomOut() {
            scale /= 1.2;
            renderPage(pageNum);
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                fabricCanvas.loadFromJSON(history[historyIndex], fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                fabricCanvas.loadFromJSON(history[historyIndex], fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        function exportPDF() {
            saveCurrentPageDrawing();
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF();
            let addPage = false;

            (async () => {
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale });
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    await page.render({ canvasContext: tempCtx, viewport }).promise;

                    const tempFabric = new fabric.StaticCanvas(tempCanvas);
                    if (pageDrawings[i]) {
                        await new Promise(resolve => {
                            tempFabric.loadFromJSON(pageDrawings[i], () => {
                                tempFabric.renderAll();
                                resolve();
                            });
                        });
                    }

                    const img = tempCanvas.toDataURL('image/jpeg', 1.0);
                    if (addPage) pdf.addPage();
                    pdf.addImage(img, 'JPEG', 0, 0, 210, 297);
                    addPage = true;
                }
                pdf.save("annotated.pdf");
            })();
        }

        document.getElementById('pdf-loader').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') loadPDF(file);
            else alert("PDF 파일만 선택 가능합니다.");
        });

        penColor.addEventListener('change', () => {
            fabricCanvas.freeDrawingBrush.color = penColor.value;
        });
        penWidth.addEventListener('change', () => {
            fabricCanvas.freeDrawingBrush.width = parseInt(penWidth.value);
        });

        pdfCanvas.addEventListener('mousedown', e => {
            if (mode !== 'move') return;
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
        });
        pdfCanvas.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            document.getElementById('pdf-container').scrollLeft -= dx;
            document.getElementById('pdf-container').scrollTop -= dy;
            startX = e.clientX;
            startY = e.clientY;
        });
        pdfCanvas.addEventListener('mouseup', () => isDragging = false);
        pdfCanvas.addEventListener('mouseleave', () => isDragging = false);

        pdfCanvas.addEventListener('touchstart', e => {
            if (mode !== 'move') return;
            const touch = e.touches[0];
            isDragging = true;
            startX = touch.clientX;
            startY = touch.clientY;
        });
        pdfCanvas.addEventListener('touchmove', e => {
            if (!isDragging) return;
            const touch = e.touches[0];
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            document.getElementById('pdf-container').scrollLeft -= dx;
            document.getElementById('pdf-container').scrollTop -= dy;
            startX = touch.clientX;
            startY = touch.clientY;
        });
        pdfCanvas.addEventListener('touchend', () => isDragging = false);

        fabricCanvas.on('object:added', () => { if (!fabricCanvas._loading) saveHistory(); });
        fabricCanvas.on('object:modified', saveHistory);
        fabricCanvas.on('object:removed', saveHistory);

        setMode('move');
    </script>
</body>
</html>
