<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PDF TEST 25061202</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #f8f9fa;
            color: #333;
            padding: 8px 12px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            z-index: 1000;
            border-bottom: 1px solid #dee2e6;
            gap: 8px;
            height: 50px; /* Toolbar height */
        }
        #toolbar button, #toolbar select, #toolbar input[type="file"]::file-selector-button {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            background-color: #fff;
            color: #495057;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #toolbar span {
            font-size: 14px;
            white-space: nowrap;
        }
        #pdf-container {
            position: fixed;
            top: 60px; /* Toolbar height + margin */
            bottom: 0;
            left: 0;
            right: 0;
            overflow: auto;
            background-color: #e9ecef;
            text-align: center;
        }
        #canvas-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #pdf-bg-canvas {
            z-index: 1;
        }
        #pdf-canvas {
            z-index: 2;
            touch-action: none;
        }
        #mode-indicator {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <input type="file" id="pdf-loader" accept="application/pdf">
        <button onclick="prevPage()">⬅ 이전</button>
        <span>페이지 <span id="page-num">0</span> / <span id="page-count">0</span></span>
        <button onclick="nextPage()">다음 ➡</button>
        <button onclick="setMode('move')">이동</button>
        <button onclick="setMode('draw')">서명</button>
        <input type="color" id="pen-color" value="#E53935">
        <select id="pen-width">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="4">4</option>
            <option value="8">8</option>
        </select>
        <button onclick="undo()">↩ 실행 취소</button>
        <button onclick="redo()">↪ 다시 실행</button>
        <button onclick="zoomIn()">➕ 확대</button>
        <button onclick="zoomOut()">➖ 축소</button>
        <button onclick="exportPDF()">저장하기</button>
    </div>

    <div id="pdf-container">
        <div id="canvas-wrapper">
            <canvas id="pdf-bg-canvas"></canvas>
            <canvas id="pdf-canvas"></canvas>
        </div>
    </div>

    <div id="mode-indicator">모드: 이동</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null, pageNum = 1, scale = 1.5;
        // ✨✨✨ 오류 수정: pdfCanvas 변수 선언 추가 ✨✨✨
        const pdfCanvas = document.getElementById('pdf-canvas');
        const bgCanvas = document.getElementById('pdf-bg-canvas');
        const ctx = bgCanvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const penColor = document.getElementById('pen-color');
        const penWidth = document.getElementById('pen-width');
        const modeIndicator = document.getElementById('mode-indicator');

        let fabricCanvas = new fabric.Canvas('pdf-canvas', {
            isDrawingMode: false,
            selection: false
        });

        let mode = 'move';
        let history = [], historyIndex = -1;
        let pageDrawings = {};
        let isDragging = false, startX = 0, startY = 0;

        function setMode(newMode) {
            mode = newMode;
            fabricCanvas.isDrawingMode = (mode === 'draw');
            if (fabricCanvas.isDrawingMode) {
                fabricCanvas.freeDrawingBrush.color = penColor.value;
                fabricCanvas.freeDrawingBrush.width = parseInt(penWidth.value, 10);
            }
            modeIndicator.textContent = '모드: ' + (mode === 'move' ? '이동' : '서명');
        }

        function saveHistory() {
            if (fabricCanvas._loading) return;
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(JSON.stringify(fabricCanvas));
            historyIndex++;
        }

        async function loadPDF(file) {
            const reader = new FileReader();
            reader.onload = async function () {
                try {
                    const typedArray = new Uint8Array(reader.result);
                    pdfDoc = await pdfjsLib.getDocument({ data: typedArray }).promise;
                    document.getElementById('page-count').textContent = pdfDoc.numPages;
                    pageNum = 1;
                    pageDrawings = {};
                    renderPage(pageNum);
                } catch (err) {
                    alert('PDF 로딩 실패');
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            if (!pdfDoc) return;
            const page = await pdfDoc.getPage(num);
            const viewport = page.getViewport({ scale });

            bgCanvas.width = pdfCanvas.width = viewport.width;
            bgCanvas.height = pdfCanvas.height = viewport.height;

            bgCanvas.style.width = pdfCanvas.style.width = viewport.width + "px";
            bgCanvas.style.height = pdfCanvas.style.height = viewport.height + "px";

            canvasWrapper.style.width = viewport.width + "px";
            canvasWrapper.style.height = viewport.height + "px";

            await page.render({ canvasContext: ctx, viewport }).promise;

            fabricCanvas.setWidth(viewport.width);
            fabricCanvas.setHeight(viewport.height);
            fabricCanvas.clear();

            if (pageDrawings[num]) {
                fabricCanvas._loading = true;
                fabricCanvas.loadFromJSON(pageDrawings[num], () => {
                    fabricCanvas.renderAll();
                    fabricCanvas._loading = false;
                });
            }
            
            history = [JSON.stringify(fabricCanvas)];
            historyIndex = 0;

            document.getElementById('page-num').textContent = pageNum;
        }

        function saveCurrentPageDrawing() {
            if (pdfDoc) {
                pageDrawings[pageNum] = JSON.stringify(fabricCanvas);
            }
        }

        function prevPage() {
            if (pageNum <= 1) return;
            saveCurrentPageDrawing();
            pageNum--;
            renderPage(pageNum);
        }

        function nextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            saveCurrentPageDrawing();
            pageNum++;
            renderPage(pageNum);
        }

        function zoomIn() {
            if (!pdfDoc) return;
            scale *= 1.2;
            renderPage(pageNum);
        }

        function zoomOut() {
            if (!pdfDoc) return;
            scale /= 1.2;
            renderPage(pageNum);
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                fabricCanvas.loadFromJSON(history[historyIndex], fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                fabricCanvas.loadFromJSON(history[historyIndex], fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        async function exportPDF() {
            if (!pdfDoc) {
                alert("먼저 PDF 파일을 로드해주세요.");
                return;
            }
            saveCurrentPageDrawing();
            
            const { jsPDF } = window.jspdf;
            let pdf;

            const firstPageForInfo = await pdfDoc.getPage(1);
            const firstViewport = firstPageForInfo.getViewport({ scale: 1 });
            const orientation = firstViewport.width > firstViewport.height ? 'l' : 'p';
            pdf = new jsPDF({ orientation, unit: 'pt', format: [firstViewport.width, firstViewport.height] });

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 1 });
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                await page.render({ canvasContext: tempCtx, viewport }).promise;

                if (pageDrawings[i]) {
                    const tempFabric = new fabric.Canvas(null);
                    tempFabric.setWidth(viewport.width);
                    tempFabric.setHeight(viewport.height);
                    
                    await new Promise(resolve => {
                       tempFabric.loadFromJSON(pageDrawings[i], () => {
                           tempCtx.drawImage(tempFabric.getElement(), 0, 0);
                           resolve();
                       });
                    });
                }

                const img = tempCanvas.toDataURL('image/png');
                
                if (i > 1) {
                    pdf.addPage([viewport.width, viewport.height], viewport.width > viewport.height ? 'l' : 'p');
                } else {
                    const pageInfo = pdf.getCurrentPageInfo();
                    pageInfo.pageContext.mediaBox.upperRightX = viewport.width;
                    pageInfo.pageContext.mediaBox.upperRightY = viewport.height;
                }
                pdf.addImage(img, 'PNG', 0, 0, viewport.width, viewport.height);
            }
            pdf.save("annotated.pdf");
        }

        document.getElementById('pdf-loader').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                loadPDF(file);
            } else {
                alert("PDF 파일만 선택 가능합니다.");
            }
        });

        penColor.addEventListener('change', () => {
            if (fabricCanvas.isDrawingMode) {
                fabricCanvas.freeDrawingBrush.color = penColor.value;
            }
        });

        penWidth.addEventListener('change', () => {
            if (fabricCanvas.isDrawingMode) {
                fabricCanvas.freeDrawingBrush.width = parseInt(penWidth.value, 10);
            }
        });

        fabricCanvas.on('mouse:down', function(o) {
            if (mode !== 'move') return;
            isDragging = true;
            const e = o.e;
            if (e.touches) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            } else {
                startX = e.clientX;
                startY = e.clientY;
            }
            o.e.preventDefault();
            o.e.stopPropagation();
        });

        fabricCanvas.on('mouse:move', function(o) {
            if (!isDragging || mode !== 'move') return;
            const e = o.e;
            let currentX, currentY;
            if (e.touches) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            const dx = currentX - startX;
            const dy = currentY - startY;
            document.getElementById('pdf-container').scrollLeft -= dx;
            document.getElementById('pdf-container').scrollTop -= dy;
            startX = currentX;
            startY = currentY;
        });

        fabricCanvas.on('mouse:up', function(o) {
            if (mode !== 'move') return;
            isDragging = false;
        });
        
        fabricCanvas.on('mouse:out', function(o) {
            if (mode !== 'move') return;
            isDragging = false;
        });

        fabricCanvas.on('object:added', () => { if (!fabricCanvas._loading) saveHistory(); });

        setMode('move');
    </script>
</body>
</html>