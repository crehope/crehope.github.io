<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Annotator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    #pdf-container { position: relative; display: inline-block; }
    canvas { border: 1px solid #ccc; display: block; }
    #toolbar { margin-bottom: 10px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="file" id="file-input" accept="application/pdf">
    <button onclick="setMode('pan')">이동</button>
    <button onclick="setMode('draw')">서명</button>
    <button onclick="setMode('text')">텍스트</button>
    <input type="color" id="font-color" value="#000000">
    <input type="number" id="font-size" value="20" min="10" max="100">
  </div>
  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
    <canvas id="fg-canvas"></canvas>
  </div>

  <script>
    let pdfDoc = null;
    let currentPage = 1;
    let scale = 1.5;
    let pdfCanvas = document.getElementById('pdf-canvas');
    let fgCanvas = document.getElementById('fg-canvas');
    let pdfCtx = pdfCanvas.getContext('2d');
    let fabricCanvas = null;
    let mode = 'pan';
    let annotations = {};

    document.getElementById('file-input').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const fileReader = new FileReader();
      fileReader.onload = async function() {
        const typedarray = new Uint8Array(this.result);
        pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
        currentPage = 1;
        annotations = {};
        renderPage(currentPage);
      };
      fileReader.readAsArrayBuffer(file);
    });

    async function renderPage(pageNum) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: scale });
      pdfCanvas.height = viewport.height;
      pdfCanvas.width = viewport.width;
      fgCanvas.height = viewport.height;
      fgCanvas.width = viewport.width;

      const renderContext = {
        canvasContext: pdfCtx,
        viewport: viewport
      };
      await page.render(renderContext).promise;
      initFabricCanvas();
    }

    function initFabricCanvas() {
      fabricCanvas = new fabric.Canvas('fg-canvas', {
        isDrawingMode: false,
        selection: false,
        preserveObjectStacking: true
      });

      if (annotations[currentPage]) {
        fabricCanvas.loadFromJSON(annotations[currentPage], fabricCanvas.renderAll.bind(fabricCanvas));
      }

      fabricCanvas.on('object:added', saveHistory);
      fabricCanvas.on('object:modified', saveHistory);
      fabricCanvas.on('object:removed', saveHistory);

      fabricCanvas.on('mouse:down', function(opt) {
        if (mode === 'text') {
          const pointer = fabricCanvas.getPointer(opt.e);
          const text = new fabric.Textbox('텍스트', {
            left: pointer.x,
            top: pointer.y,
            fontSize: parseInt(document.getElementById('font-size').value, 10),
            fill: document.getElementById('font-color').value,
            editable: true
          });
          fabricCanvas.add(text).setActiveObject(text);
          saveHistory();
        }
      });

      setMode(mode);
    }

    function saveAnnotations() {
      if (fabricCanvas) {
        annotations[currentPage] = JSON.stringify(fabricCanvas);
      }
    }

    function setMode(m) {
      mode = m;
      if (!fabricCanvas) return;

      fabricCanvas.isDrawingMode = (mode === 'draw');
      if (mode === 'draw') {
        fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
        fabricCanvas.freeDrawingBrush.color = document.getElementById('font-color').value;
        fabricCanvas.freeDrawingBrush.width = 2;
      }

      const isText = (mode === 'text');
      fabricCanvas.selection = isText;
      fabricCanvas.forEachObject(obj => {
        obj.selectable = isText;
        obj.evented = isText;
        obj.hasControls = isText;
      });

      enablePanModeEvents();
    }

    function saveHistory() {
      saveAnnotations();
    }

    let isDragging = false;
    let lastPosX = 0, lastPosY = 0;

    function enablePanModeEvents() {
      if (!fabricCanvas) return;

      fabricCanvas.off('mouse:down');
      fabricCanvas.off('mouse:move');
      fabricCanvas.off('mouse:up');

      fabricCanvas.on('mouse:down', function (opt) {
        if (mode !== 'pan') return;
        isDragging = true;
        const pointer = fabricCanvas.getPointer(opt.e);
        lastPosX = pointer.x;
        lastPosY = pointer.y;
        fabricCanvas.selection = false;
      });

      fabricCanvas.on('mouse:move', function (opt) {
        if (!isDragging || mode !== 'pan') return;
        const pointer = fabricCanvas.getPointer(opt.e);
        const dx = pointer.x - lastPosX;
        const dy = pointer.y - lastPosY;
        fabricCanvas.relativePan(new fabric.Point(dx, dy));
        lastPosX = pointer.x;
        lastPosY = pointer.y;
      });

      fabricCanvas.on('mouse:up', function () {
        isDragging = false;
        fabricCanvas.selection = true;
      });

      window.addEventListener('keydown', function (e) {
        if (mode !== 'pan') return;
        const delta = 10;
        switch (e.key) {
          case 'ArrowUp':
            fabricCanvas.relativePan({ x: 0, y: delta }); break;
          case 'ArrowDown':
            fabricCanvas.relativePan({ x: 0, y: -delta }); break;
          case 'ArrowLeft':
            fabricCanvas.relativePan({ x: delta, y: 0 }); break;
          case 'ArrowRight':
            fabricCanvas.relativePan({ x: -delta, y: 0 }); break;
        }
      });

      let lastTouchDistance = 0;
      fgCanvas.addEventListener('touchmove', function (e) {
        if (mode !== 'pan' || e.touches.length !== 2) return;
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (lastTouchDistance === 0) {
          lastTouchDistance = dist;
          return;
        }

        if (Math.abs(dist - lastTouchDistance) > 10) {
          scale += (dist > lastTouchDistance) ? 0.05 : -0.05;
          scale = Math.max(0.5, Math.min(3, scale));
          saveAnnotations();
          renderPage(currentPage);
          lastTouchDistance = dist;
        }
      });

      fgCanvas.addEventListener('touchend', () => {
        lastTouchDistance = 0;
      });
    }

    document.addEventListener('dblclick', function (e) {
      if (mode !== 'text') return;
      const pointer = fabricCanvas.getPointer(e);
      const target = fabricCanvas.findTarget(e);
      if (target && target.type === 'textbox') {
        const newText = prompt("텍스트 수정:", target.text);
        if (newText !== null) {
          target.text = newText;
          fabricCanvas.requestRenderAll();
          saveHistory();
        }
      }
    });
  </script>
</body>
</html>
