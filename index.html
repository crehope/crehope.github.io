<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PDF 주석 및 서명 도구</title>
    <style>
        /* General body styling to prevent default scrollbars and touch actions */
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden; /* Prevent body scrolling */
        }

        /* Toolbar styling */
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #f8f9fa;
            color: #333;
            padding: 8px 12px;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            align-items: center;
            z-index: 1000;
            border-bottom: 1px solid #dee2e6;
            gap: 8px;
        }

        #toolbar button,
        #toolbar select,
        #toolbar input[type="file"]::file-selector-button {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            background-color: #fff;
            color: #495057;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s, border-color 0.2s;
        }

        #toolbar button:hover,
        #toolbar select:hover,
        #toolbar input[type="file"]::file-selector-button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }

        #toolbar span {
            font-size: 14px;
            white-space: nowrap; /* Prevent page info from wrapping */
        }

        /* Container for the PDF viewer */
        #pdf-container {
            position: fixed;
            top: 60px; /* Adjust based on toolbar height */
            bottom: 0;
            left: 0;
            right: 0;
            overflow: auto; /* Allows scrolling/panning */
            background-color: #e9ecef;
            text-align: center; /* Center the canvas wrapper */
            /* Cursors for different modes */
            cursor: grab; /* Default cursor for pan mode */
        }

        #pdf-container.draw-mode {
            cursor: crosshair; /* Cursor for draw mode */
        }

        #pdf-container:active {
            cursor: grabbing; /* Cursor when panning */
        }
        
        /* Wrapper to position canvases correctly */
        #canvas-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px 0; /* Add some space around the canvas */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Styling for both PDF background and Fabric.js canvas */
        #pdf-bg-canvas,
        #pdf-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #pdf-bg-canvas { z-index: 1; }
        #pdf-canvas { z-index: 2; }

    </style>
</head>

<body>

    <div id="toolbar">
        <!-- PDF file loader -->
        <input type="file" id="pdf-loader" accept="application/pdf" onchange="loadPDF(this.files[0])" title="PDF 파일 열기">
        
        <!-- Page navigation -->
        <button onclick="prevPage()">⬅ 이전</button>
        <span>페이지 <span id="page-num">0</span> / <span id="page-count">0</span></span>
        <button onclick="nextPage()">다음 ➡</button>

        <!-- Mode toggle button -->
        <button id="mode-toggle" onclick="toggleMode()">이동</button>

        <!-- Drawing options -->
        <input type="color" id="pen-color" value="#E53935" title="펜 색상">
        <select id="pen-width" title="펜 두께">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="4">4</option>
            <option value="8">8</option>
        </select>

        <!-- History controls -->
        <button onclick="undo()">↩ 실행 취소</button>
        <button onclick="redo()">↪ 다시 실행</button>
        
        <!-- Zoom controls -->
        <button onclick="zoomIn()">➕ 확대</button>
        <button onclick="zoomOut()">➖ 축소</button>

        <!-- Save/Export button -->
        <button onclick="exportPDF()">저장하기</button>
    </div>

    <div id="pdf-container">
        <div id="canvas-wrapper">
            <!-- Canvas for rendering the PDF page background -->
            <canvas id="pdf-bg-canvas"></canvas>
            <!-- Canvas for Fabric.js annotations -->
            <canvas id="pdf-canvas"></canvas>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State variables
        let pdfDoc = null;
        let currentPage = 1;
        let scale = 1.5;
        let fabricCanvas = null;
        let annotations = {};
        let mode = 'draw'; // Initial mode is 'draw'
        let currentRenderTask = null; // To manage PDF rendering tasks

        // History stacks
        let undoStack = [];
        let redoStack = [];
        let currentHistoryState = null;

        // Panning and zooming state
        let isPanning = false;
        let lastPanX, lastPanY;
        let touchState = {
            initialDist: 0,
            isPinching: false,
            initialScale: 1.5
        };

        // DOM elements
        const bgCanvas = document.getElementById('pdf-bg-canvas');
        const fgCanvas = document.getElementById('pdf-canvas');
        const container = document.getElementById('pdf-container');
        const modeToggleButton = document.getElementById('mode-toggle');
        const pageNumEl = document.getElementById('page-num');
        const pageCountEl = document.getElementById('page-count');
        
        // Initialize the app
        function init() {
            setupEventListeners();
            setMode(mode); // Set initial mode
        }

        // --- Mode Management ---
        function toggleMode() {
            mode = (mode === 'draw') ? 'pan' : 'draw';
            setMode(mode);
        }

        function setMode(newMode) {
            mode = newMode;
            if (mode === 'draw') {
                modeToggleButton.textContent = '이동';
                container.classList.add('draw-mode');
                container.classList.remove('pan-mode');
                if (fabricCanvas) {
                    fabricCanvas.isDrawingMode = true;
                }
            } else { // pan mode
                modeToggleButton.textContent = '작성';
                container.classList.remove('draw-mode');
                container.classList.add('pan-mode');
                if (fabricCanvas) {
                    fabricCanvas.isDrawingMode = false;
                }
            }
        }
        
        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Pan listeners (mouse)
            container.addEventListener('mousedown', handlePanStart);
            container.addEventListener('mousemove', handlePanMove);
            container.addEventListener('mouseup', handlePanEnd);
            container.addEventListener('mouseleave', handlePanEnd); // Stop panning if mouse leaves container

            // Pan listeners (touch)
            container.addEventListener('touchstart', handlePanStart);
            container.addEventListener('touchmove', handlePanMove);
            container.addEventListener('touchend', handlePanEnd);
            
            // Zoom listener
            container.addEventListener('wheel', handleWheelZoom, { passive: false });

            // Keyboard pan listener
            window.addEventListener('keydown', handleKeyDown);
            
            // Brush property listeners
            document.getElementById('pen-color').addEventListener('change', (e) => {
                if(fabricCanvas) fabricCanvas.freeDrawingBrush.color = e.target.value;
            });
            document.getElementById('pen-width').addEventListener('change', (e) => {
                if(fabricCanvas) fabricCanvas.freeDrawingBrush.width = parseInt(e.target.value, 10);
            });
        }

        // --- PDF Rendering ---
        function loadPDF(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                const loadingTask = pdfjsLib.getDocument({ data: e.target.result });
                loadingTask.promise.then(doc => {
                    pdfDoc = doc;
                    annotations = {};
                    undoStack = [];
                    redoStack = [];
                    currentPage = 1;
                    pageCountEl.textContent = pdfDoc.numPages;
                    renderPage(currentPage);
                });
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;

            // Cancel any ongoing render task to prevent errors
            if (currentRenderTask) {
                currentRenderTask.cancel();
            }

            saveAnnotations();
            currentPage = num;
            pageNumEl.textContent = num;
            
            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale });
                
                // Set canvas dimensions
                [bgCanvas, fgCanvas].forEach(c => {
                    c.width = viewport.width;
                    c.height = viewport.height;
                    c.style.width = `${viewport.width}px`;
                    c.style.height = `${viewport.height}px`;
                });
                
                // Start the new render task
                const renderContext = {
                    canvasContext: bgCanvas.getContext('2d'),
                    viewport
                };
                currentRenderTask = page.render(renderContext);
                
                await currentRenderTask.promise;
                currentRenderTask = null; // Clear task on successful completion

                // Initialize or update Fabric.js canvas
                initFabricCanvas(viewport);

            } catch (error) {
                // A RenderingCancelledException is expected when we cancel, so we ignore it.
                if (error.name !== 'RenderingCancelledException') {
                    console.error("Render error:", error);
                }
            }
        }
        
        function initFabricCanvas(viewport) {
            if (fabricCanvas) {
                fabricCanvas.dispose();
            }
            fabricCanvas = new fabric.Canvas('pdf-canvas', {
                width: viewport.width,
                height: viewport.height,
                isDrawingMode: mode === 'draw',
            });
            
            // Set brush properties
            fabricCanvas.freeDrawingBrush.color = document.getElementById('pen-color').value;
            fabricCanvas.freeDrawingBrush.width = parseInt(document.getElementById('pen-width').value, 10);

            // Load annotations for the current page
            loadAnnotations();
            
            // Setup history tracking for drawing actions
            fabricCanvas.on('path:created', saveHistory);
        }

        // --- Annotation and History Management ---
        function saveAnnotations() {
            if (fabricCanvas) {
                // Store both the data and the scale at which it was saved for accurate exporting
                annotations[currentPage] = {
                    data: fabricCanvas.toJSON(),
                    scale: scale
                };
            }
        }

        function loadAnnotations() {
            const savedAnnotation = annotations[currentPage];
            if (savedAnnotation && fabricCanvas) {
                fabricCanvas.loadFromJSON(savedAnnotation.data, fabricCanvas.renderAll.bind(fabricCanvas));
            }
            // Always save history, even for a blank page, to enable 'undo' back to the initial state.
            saveHistory();
        }
        
        function saveHistory() {
            if (!fabricCanvas) return;
            redoStack = []; // Clear redo stack on new action
            const json = fabricCanvas.toJSON();
            // Prevent saving duplicate states
            if (currentHistoryState && JSON.stringify(json) === JSON.stringify(currentHistoryState)) {
                return;
            }
            undoStack.push(json);
            currentHistoryState = json;
        }

        function undo() {
            if (undoStack.length > 1 && fabricCanvas) {
                redoStack.push(undoStack.pop());
                const prevState = undoStack[undoStack.length - 1];
                currentHistoryState = prevState;
                fabricCanvas.loadFromJSON(prevState, fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        function redo() {
            if (redoStack.length > 0 && fabricCanvas) {
                const nextState = redoStack.pop();
                undoStack.push(nextState);
                currentHistoryState = nextState;
                fabricCanvas.loadFromJSON(nextState, fabricCanvas.renderAll.bind(fabricCanvas));
            }
        }

        // --- Navigation ---
        function prevPage() {
            if (currentPage > 1) {
                renderPage(currentPage - 1);
            }
        }

        function nextPage() {
            if (pdfDoc && currentPage < pdfDoc.numPages) {
                renderPage(currentPage + 1);
            }
        }

        // --- Pan and Zoom ---
        function handlePanStart(e) {
            if (mode !== 'pan') return;

            // Handle touch and mouse events
            if (e.touches && e.touches.length === 2) {
                handlePinchStart(e);
                return;
            }
            
            isPanning = true;
            lastPanX = e.touches ? e.touches[0].clientX : e.clientX;
            lastPanY = e.touches ? e.touches[0].clientY : e.clientY;
            container.style.cursor = 'grabbing';
        }

        function handlePanMove(e) {
            // Handle pinch zoom
            if (e.touches && e.touches.length === 2 && touchState.isPinching) {
                handlePinchMove(e);
                return;
            }
            
            if (!isPanning || mode !== 'pan') return;
            e.preventDefault();
            
            const currentX = e.touches ? e.touches[0].clientX : e.clientX;
            const currentY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const deltaX = currentX - lastPanX;
            const deltaY = currentY - lastPanY;
            
            container.scrollLeft -= deltaX;
            container.scrollTop -= deltaY;
            
            lastPanX = currentX;
            lastPanY = currentY;
        }
        
        function handlePanEnd(e) {
            isPanning = false;
            container.style.cursor = 'grab';
            
            if (e.touches && e.touches.length < 2) {
                touchState.isPinching = false;
            }
        }

        function handlePinchStart(e) {
            touchState.isPinching = true;
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            touchState.initialDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            touchState.initialScale = scale;
        }

        function handlePinchMove(e) {
            e.preventDefault();
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            const currentDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            const scaleFactor = currentDist / touchState.initialDist;
            const newScale = touchState.initialScale * scaleFactor;
            
            scale = Math.max(0.5, Math.min(newScale, 5.0)); // Clamp scale
            renderPage(currentPage);
        }

        function handleWheelZoom(e) {
            e.preventDefault(); // Prevent page from scrolling
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            const newScale = scale + delta;
            scale = Math.max(0.5, Math.min(newScale, 5.0)); // Clamp scale
            renderPage(currentPage);
        }

        function handleKeyDown(e) {
            if (mode !== 'pan') return;
            const step = 30; // pixels to scroll
            switch (e.key) {
                case 'ArrowUp': container.scrollTop -= step; break;
                case 'ArrowDown': container.scrollTop += step; break;
                case 'ArrowLeft': container.scrollLeft -= step; break;
                case 'ArrowRight': container.scrollLeft += step; break;
            }
        }

        function zoomIn() {
            scale = Math.min(scale + 0.2, 5.0);
            renderPage(currentPage);
        }

        function zoomOut() {
            scale = Math.max(scale - 0.2, 0.5);
            renderPage(currentPage);
        }
        
        // --- Export ---
        async function exportPDF() {
            if (!pdfDoc) return;
            saveAnnotations(); // Save current page before exporting

            const { jsPDF } = window.jspdf;
            const page = await pdfDoc.getPage(1);
            const firstViewport = page.getViewport({ scale: 1.0 });

            const newPdf = new jsPDF({
                orientation: firstViewport.width > firstViewport.height ? 'l' : 'p',
                unit: 'pt',
                format: [firstViewport.width, firstViewport.height]
            });

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const exportScale = 2.0; // Use a consistent high scale for export quality
                const viewport = page.getViewport({ scale: exportScale });
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                await page.render({ canvasContext: tempCtx, viewport }).promise;

                const savedAnnotation = annotations[i];
                if (savedAnnotation) {
                    const tempFabric = new fabric.Canvas(null);
                    tempFabric.setDimensions({ width: viewport.width, height: viewport.height });
                    await new Promise(resolve => {
                        tempFabric.loadFromJSON(savedAnnotation.data, () => {
                           const scaleRatio = exportScale / savedAnnotation.scale;
                           tempFabric.getObjects().forEach(obj => {
                               obj.scaleX *= scaleRatio;
                               obj.scaleY *= scaleRatio;
                               obj.left *= scaleRatio;
                               obj.top *= scaleRatio;
                               obj.setCoords();
                           });
                           tempFabric.renderAll();
                           tempCtx.drawImage(tempFabric.getElement(), 0, 0);
                           resolve();
                        });
                    });
                }
                
                const imgData = tempCanvas.toDataURL('image/jpeg', 0.9);
                const pdfWidth = newPdf.internal.pageSize.getWidth();
                const pdfHeight = (viewport.height / viewport.width) * pdfWidth;
                
                if (i > 1) {
                    newPdf.addPage([pdfWidth, pdfHeight], viewport.width > viewport.height ? 'l' : 'p');
                }
                newPdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }

            newPdf.save('annotated_document.pdf');
        }

        // Initialize on load
        window.onload = init;
    </script>

</body>
</html>
