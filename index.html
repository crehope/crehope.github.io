<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF ì£¼ì„ ë° ì„œëª… ë„êµ¬</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #333;
            color: white;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            z-index: 10;
            gap: 6px;
        }

        #toolbar>* {
            margin: 2px;
        }

        #pdf-container {
            position: absolute;
            top: 60px;
            bottom: 0;
            left: 0;
            right: 0;
            overflow: auto;
            touch-action: none;
        }

        #canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        #pdf-bg-canvas,
        #pdf-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #pdf-bg-canvas {
            z-index: 0;
        }

        #pdf-canvas {
            z-index: 1;
        }
    </style>
</head>

<body>

    <div id="toolbar">
        <button onclick="prevPage()">â¬… ì´ì „</button>
        <span>í˜ì´ì§€ <span id="page-num">1</span> / <span id="page-count">?</span></span>
        <button onclick="nextPage()">ë‹¤ìŒ â¡</button>

        <button onclick="setMode('pan')">ì´ë™</button>
        <button onclick="setMode('draw')">ì„œëª…</button>
        <button onclick="setMode('text')">í…ìŠ¤íŠ¸</button>
        <button onclick="addText()">í…ìŠ¤íŠ¸ ì¶”ê°€</button>

        <input type="color" id="font-color" value="#000000">
        <select id="font-size">
            <option value="16">16</option>
            <option value="20" selected>20</option>
            <option value="24">24</option>
        </select>

        <button onclick="undo()">â†© ì‹¤í–‰ ì·¨ì†Œ</button>
        <button onclick="redo()">â†ª ë‹¤ì‹œ ì‹¤í–‰</button>

        <button onclick="zoomIn()">ğŸ” í™•ëŒ€</button>
        <button onclick="zoomOut()">ğŸ” ì¶•ì†Œ</button>

        <input type="file" accept="image/*" onchange="addImageSignature(this)">
        <input type="file" accept="application/pdf" onchange="loadPDF(this)">
        <input type="file" accept=".json" onchange="loadFromFile(this)">
        <button onclick="downloadAnnotations()">ì£¼ì„ ì €ì¥</button>
        <button onclick="uploadAnnotationsToServer()">ì„œë²„ì— ì €ì¥</button>
        <button onclick="loadAnnotationsFromServer()">ì„œë²„ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button onclick="exportPDF()">PDFë¡œ ì €ì¥</button>
    </div>

    <div id="pdf-container">
        <div id="canvas-wrapper">
            <canvas id="pdf-bg-canvas"></canvas> <!-- PDF ë Œë”ë§ìš© -->
            <canvas id="pdf-canvas"></canvas> <!-- Fabric.jsìš© -->
        </div>
    </div>

    <!-- ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null,
            currentPage = 1,
            scale = 1.5;
        let fabricCanvas = null,
            renderTask = null,
            isRendering = false;
        let annotations = {},
            mode = 'pan';
        let undoStack = [],
            redoStack = [];

        const bgCanvas = document.getElementById('pdf-bg-canvas');
        const fgCanvas = document.getElementById('pdf-canvas');
        const bgCtx = bgCanvas.getContext('2d');

        function setMode(m) {
            mode = m;
            if (!fabricCanvas) return;

            // ë“œë¡œì‰ ëª¨ë“œ ì„¤ì •
            fabricCanvas.isDrawingMode = (mode === 'draw');
            if (mode === 'draw') {
                fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
                fabricCanvas.freeDrawingBrush.color = document.getElementById('font-color').value;
                fabricCanvas.freeDrawingBrush.width = 2;
            }

            // ê°ì²´ ì„ íƒ ì„¤ì •
            const selectable = (mode === 'text' || mode === 'pan'); // ë‘˜ ë‹¤ ì¡°ì‘ í—ˆìš©
            fabricCanvas.selection = selectable;
            fabricCanvas.forEachObject(obj => {
                obj.selectable = selectable;
                obj.evented = selectable;
                obj.hasControls = selectable;
            });
        }

        function saveHistory() {
            if (!fabricCanvas) return;
            undoStack.push(fabricCanvas.toJSON());
            if (undoStack.length > 50) undoStack.shift();
            redoStack = [];
        }

        function undo() {
            if (!undoStack.length) return;
            redoStack.push(fabricCanvas.toJSON());
            const prev = undoStack.pop();
            fabricCanvas.loadFromJSON(prev, () => fabricCanvas.renderAll());
        }

        function redo() {
            if (!redoStack.length) return;
            undoStack.push(fabricCanvas.toJSON());
            const next = redoStack.pop();
            fabricCanvas.loadFromJSON(next, () => fabricCanvas.renderAll());
        }

        function addText() {
            if (!fabricCanvas) return;
            const input = prompt("í…ìŠ¤íŠ¸ ì…ë ¥:");
            if (!input) return;
            const textbox = new fabric.Textbox(input, {
                left: 100,
                top: 100,
                fontSize: parseInt(document.getElementById('font-size').value),
                fill: document.getElementById('font-color').value,
                selectable: true,
                hasControls: true
            });
            fabricCanvas.add(textbox);
            fabricCanvas.setActiveObject(textbox);
            fabricCanvas.requestRenderAll();
            saveHistory();
        }

        function addImageSignature(input) {
            const reader = new FileReader();
            reader.onload = e => {
                fabric.Image.fromURL(e.target.result, img => {
                    img.scale(0.3);
                    img.set({
                        left: 100,
                        top: 100,
                        selectable: true,
                        hasControls: true,
                        lockUniScaling: false
                    });
                    fabricCanvas.add(img);
                    fabricCanvas.setActiveObject(img);
                    fabricCanvas.requestRenderAll();
                    saveHistory();
                });
            };
            reader.readAsDataURL(input.files[0]);
        }

        function saveAnnotations() {
            if (fabricCanvas) {
                annotations[currentPage] = JSON.stringify(fabricCanvas.toJSON());
            }
        }

        function loadAnnotations() {
            const data = annotations[currentPage];
            if (data) {
                fabricCanvas.loadFromJSON(data, () => {
                    fabricCanvas.renderAll();
                });
            }
        }

        function initFabricCanvas(viewport) {
            if (fabricCanvas) fabricCanvas.dispose();

            fabricCanvas = new fabric.Canvas('pdf-canvas', {
                selection: mode === 'text',
                isDrawingMode: mode === 'draw',
                preserveObjectStacking: true
            });

            fabricCanvas.setWidth(viewport.width);
            fabricCanvas.setHeight(viewport.height);
            fgCanvas.style.width = viewport.width + "px";
            fgCanvas.style.height = viewport.height + "px";
            bgCanvas.style.width = viewport.width + "px";
            bgCanvas.style.height = viewport.height + "px";

            fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
            fabricCanvas.freeDrawingBrush.color = document.getElementById('font-color').value;
            fabricCanvas.freeDrawingBrush.width = 2;

            ['object:added', 'object:modified', 'object:removed'].forEach(event => {
                fabricCanvas.on(event, saveHistory);
            });

            loadAnnotations();
        }

        function renderPage(num) {
            if (isRendering) return;
            isRendering = true;

            if (renderTask) {
                try {
                    renderTask.cancel();
                } catch {}
                renderTask = null;
            }

            pdfDoc.getPage(num).then(page => {
                const viewport = page.getViewport({
                    scale
                });
                bgCanvas.width = viewport.width;
                bgCanvas.height = viewport.height;
                fgCanvas.width = viewport.width;
                fgCanvas.height = viewport.height;

                renderTask = page.render({
                    canvasContext: bgCtx,
                    viewport
                });
                return renderTask.promise.then(() => {
                    renderTask = null;
                    initFabricCanvas(viewport);
                    document.getElementById('page-num').textContent = num;
                    document.getElementById('page-count').textContent = pdfDoc.numPages;
                    isRendering = false;
                });
            }).catch(err => {
                if (!(err instanceof pdfjsLib.RenderingCancelledException)) console.error(err);
                isRendering = false;
            });
        }

        function prevPage() {
            if (currentPage <= 1) return;
            saveAnnotations();
            currentPage--;
            renderPage(currentPage);
        }

        function nextPage() {
            if (currentPage >= pdfDoc.numPages) return;
            saveAnnotations();
            currentPage++;
            renderPage(currentPage);
        }

        function loadPDF(input) {
            const file = input.files[0];
            const reader = new FileReader();
            reader.onload = e => {
                pdfjsLib.getDocument({
                    data: new Uint8Array(e.target.result)
                }).promise.then(doc => {
                    pdfDoc = doc;
                    annotations = {};
                    currentPage = 1;
                    renderPage(currentPage);
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function downloadAnnotations() {
            saveAnnotations();
            const blob = new Blob([JSON.stringify(annotations)], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'annotations.json';
            a.click();
        }

        function loadFromFile(input) {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    annotations = JSON.parse(reader.result);
                    renderPage(currentPage);
                } catch {
                    alert("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨");
                }
            };
            reader.readAsText(input.files[0]);
        }

        function uploadAnnotationsToServer() {
            saveAnnotations();
            fetch('/save-annotations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(annotations)
            }).then(res => res.ok ? alert('ì„œë²„ ì €ì¥ ì™„ë£Œ') : alert('ì €ì¥ ì‹¤íŒ¨'));
        }

        function loadAnnotationsFromServer() {
            fetch('/load-annotations')
                .then(res => res.json())
                .then(data => {
                    annotations = data;
                    renderPage(currentPage);
                })
                .catch(() => alert('ì„œë²„ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨'));
        }

        function zoomIn() {
            scale += 0.1;
            saveAnnotations();
            renderPage(currentPage);
        }

        function zoomOut() {
            scale = Math.max(0.5, scale - 0.1);
            saveAnnotations();
            renderPage(currentPage);
        }

        async function exportPDF() {
            const {
                jsPDF
            } = window.jspdf;
            const pdf = new jsPDF();

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                currentPage = i;
                saveAnnotations();
                await pdfDoc.getPage(i).then(async page => {
                    const viewport = page.getViewport({
                        scale
                    });
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    await page.render({
                        canvasContext: tempCanvas.getContext('2d'),
                        viewport
                    }).promise;

                    const tempFabric = new fabric.StaticCanvas(tempCanvas);
                    if (annotations[i]) {
                        await new Promise(resolve => tempFabric.loadFromJSON(annotations[i], () => {
                            tempFabric.renderAll();
                            resolve();
                        }));
                    }

                    const imgData = tempCanvas.toDataURL('image/png');
                    const width = pdf.internal.pageSize.getWidth();
                    const height = (viewport.height / viewport.width) * width;
                    pdf.addImage(imgData, 'PNG', 0, 0, width, height);
                    if (i < pdfDoc.numPages) pdf.addPage();
                });
            }

            pdf.save('annotated.pdf');
        }
    </script>

</body>

</html>